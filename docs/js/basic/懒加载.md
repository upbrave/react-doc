---
nav:
    title: js
    order: 1
group:
    title: 其他
    order: 1
order: 1
title: 懒加载
---

### 通过监听页面的 scroll 事件的方法来实现

### 1.offsetTop innerHeight offsetTop

首先我们获取元素 Element.offsetTop ，获取可视区高度 window.innerHeight。

随着页面滚动，实时获取滚动条的高度 scrollTop ，如果元素 Element.offsetTop - 滚动条的高度 scrollTop 小于可视区高度 window.innerHeight 的时候，开始加载数据。

##### 需要考虑的问题
- 防抖已经懒加载或者正在加载中的资源需要记录下来避免重复操作
- 加载失败的资源有重新加载的机会
- 正向和反向(也就是上滑和下滑)都可以触发懒加载
- 防抖：如果页面滚动较快，滑过的页面中的资源可以不去加载，在滑动停留的地方加载
- 阈值：加载需要提前预测，避免用户等待

### 2.getBoundingClientRect

通过 Element.getBoundingClientRect() 方法可以返回元素的大小及其相对于视口的位置;

返回值对象包含了一组用于描述边框的只读属性—— left 、top 、right 和 bottom ，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。

随着页面滚动，我们可以获取懒加载元素相对于视口的顶点位置 rectObject.top 的像素值，当这个值小于可视区高 window.innerHeight ，表示已经进入可视区，开始加载数据，如果要提前加载，可以设置一个 threshold 阈值。

<code src="./components/lazyload/lazyLoad.tsx"></code>

### IntersectionObserver
- 异步
- 把每个模块都作为一个单独的目标元素去观察，当被观察的目标元素进入根元素的可视区内，开始加载组件模块内容

**接收两个参数：**

**1. callback 回调函数**

>当被观察元素与根元素视口发生交集，或交集部分大小发生变化的时候被执行。  
>接受两个参数，第一个参数是交集信息，以 IntersectionObserverEntry 对象数组形式返回，第二个是观察者本身

交集信息如下：
```
[
  {
    boundingClientRect: DOMRectReadOnly {x: 385, y: 2754, width: 400, height: 50, top: 2754, …}
    intersectionRatio: 0
    intersectionRect: DOMRectReadOnly {x: 0, y: 0, width: 0, height: 0, top: 0, …}
    isIntersecting: false
    isVisible: false
    rootBounds: DOMRectReadOnly {x: 0, y: -50, width: 1293, height: 1046, top: -50, …}
    target: div.sc-gtsrHT.fPJvqn
    time: 899.400000005960
  }
]

```

* boundingClientRect ：目标元素的矩形区域的信息，与 Element.getBoundingClientRect() 相同。
* intersectionRect ：根元素和目标元素的交叉区域的信息。
* intersectionRatio ：目标元素的可见比例,也就是 intersectionRect 占 boundingClientRect 的比例值。这个值会大于option.thresholds
* isIntersecting ：布尔值, 如果目标元素与根元素相交，则返回 true ，否则返回 false 。
* rootBounds ：包含根元素的矩形区域的信息。
* target ：返回目标元素的 dom 节点对象，被观察的目标元素。
* time ：返回交叉被触发的时间的时间戳，是一个高精度时间戳，单位为毫秒。加载页面之后开始计算时间

> 如果callback是非常耗时的操作，会阻塞主线程，可以在requestIdleCallback中执行
**2. option 配置**

配置对象包含三个可选属性，一旦IntersectionObserver被创建，则无法更改其配置。
* root ：被观察对象的祖先元素，也就是根元素；默认值是 null，也就是根元素指向的是浏览器的视口窗口，当前窗口里的所有元素都是根元素的后代元素，都是可以被观察的。
* rootMargin ：类似于thresholds 扩大或缩小了触发的范围， 默认值为” 0px 0px 0px 0px “，可用百分比，相当扩展根元素的对应宽高的百分比的值，例如：” 0% 0% 50% 0% “，。
  
* thresholds ：这个thresholds有点字不达义，一个包含阈值的数组,比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数， 数组中的每个阈值可以是 0~1 之间的任意数值，该数值是目标元素和根元素相交的面积相对于目标元素面积的值，等于或是大于指定的阈值时就会触发回调函数。默认值为[0]，也就是开始进入，就会触发。

**常用实例方法：**
* observer.observe() ：开始观察一个目标元素。如果要观察多个节点，就要多次调用这个方法
* observer.unobserve() ：停止观察指定的目标元素。
* observer.disconnect() ：关闭观察器。

<code src="./components/lazyload/InterSectionObserverLazyLoad.tsx"></code>

**停止观察目标元素**
- 对目标元素调用unobserve(target)。
- 调用disconnect()。
- 目标元素被删除。
- 根元素被删除。
**兼容性**

IE不支持

polyfill:  
```
npm i intersection-observer
require('intersection-observer')
```
